My goal while implementing my decryption program was to incorporate some error handling and debugging messages. I first started by opening the CaesarKey.txt file, where I would extract the encryption and determine the number of bits to rotate during decryption.
For the decrypted text to be stored I initialized an empty string called plaintext. I then used the try and except blocks to ensure if any errors arose during execution, they would be handled accordingly. The goal behind this is to ensure proper code execution and completion. 

In addition, the mathematical operations in cryptography were a key component in decrypting the cipher. I employed modular arithmetic in the decryption algorithm to reverse the encryption successfully. I also utilized Python ASCII conversion and string manipulation to help in the process of decryption.

Being able to successfully iterate through the given ciphertext.txt file item by item made it possible for me to decrypt the encryption. For every character in the ciphertect.txt file ranging from A-Z, I was able to use ASCII conversion and modular arithmetic to decrypt the cipher. Also, if a character wasn't within a specified range, I would print an “error message” into the console. After the cipher was decrypted, the text would then be stored as a `plaintext` string and later written to an output file. In short, I implemented a full cycle that covers reading a caesarey.txt, decrypting the ciphertext.txt, and writing the plaintext string back to a file.

In conclusion, the code I wrote serves as a complete and functional decryption tool. While the algorithm itself is the core of the program. I believe all the constraints I used, and error handling aided me in completing this project successfully. This project has been a great programming experience, it introduced me to the complexities of encryption and decryption. I feel after this project I am ready to tackle more encryption and decryption-type programs.